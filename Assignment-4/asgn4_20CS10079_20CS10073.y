%{  

/*
 Compilers Lab
 Autumn Semester 2022
 Assignment No. 4
 Vikas Vijaykumar Bastewad - 20CS10073
 Yashraj Singh - 20CS10079
*/

/* C Declarations and Definitions */

	#include <string.h>
	#include <stdio.h>

	extern int yylex(); // Generated by Flex
    extern int line;
	void yyerror(char *s);

%}

%union {  // Placeholder for a value
	int intval;
}

// -------------------------- TOKEN DECLARATION --------------------------------
%token IDENTIFIER
%token INTEGER_CONSTANT
%token FLOATING_CONSTANT
%token CHARACTER_CONSTANT
%token ENUM_CONSTANT
%token STRING_LITERAL

%token ROUND_BRACKET_OPEN ROUND_BRACKET_CLOSE
%token SQUARE_BRACKET_OPEN SQUARE_BRACKET_CLOSE
%token CURLY_BRACKET_OPEN CURLY_BRACKET_CLOSE

%token UNARY_INCREMENT UNARY_DECREMENT NOT
%token MUL DIV MOD PLUS MINUS COMPLEMENT XOR
%token DOT DOTS COMMA QUES_MARK COLON SEMICOLON
%token IMPLIES HASH

%token BITWISE_LEFT BITWISE_RIGHT BITWISE_AND BITWISE_OR
%token LOGICAL_AND LOGICAL_OR
%token LESS_THAN GREATER_THAN LESS_EQUAL GREATER_EQUAL EQUAL NOT_EQUAL

%token ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN PLUS_ASSIGN MINUS_ASSIGN 
%token BITWISE_LEFT_ASSIGN BITWISE_RIGHT_ASSIGN BITWISE_AND_ASSIGN XOR_ASSIGN BITWISE_OR_ASSIGN

%token EXTERN STATIC VOID CHAR SHORT INT LONG FLOAT DOUBLE CONST RESTRICT VOLATILE INLINE SIZEOF TYPEDEF UNION STRUCT AUTO REGISTER SIGNED UNSIGNED BOOL COMPLEX IMAGINARY ENUM

%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR GOTO CONTINUE BREAK RETURN 

//Setting precedence for handling Dangling-if-else shift-reduce conflict 
%precedence LOWER_THAN_ELSE
%precedence ELSE

// ------------------------ STATING THE STARTING NON-TERMINAL SYMBOL ------------
%start translation_unit

%%

// -------------------------------- 1. EXPRESSIONS ------------------------------

primary_expression 
		: IDENTIFIER
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => IDENTIFIER\n", line);}
		| INTEGER_CONSTANT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => INTEGER_CONSTANT\n", line);}
		| FLOATING_CONSTANT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => FLOATING_CONSTANT\n", line);}
		| CHARACTER_CONSTANT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => CHARACTER_CONSTANT\n", line);}
		| ENUM_CONSTANT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => ENUM_CONSTANT\n", line);}
		| STRING_LITERAL
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => STRING LITERAL\n", line);}
		| ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : primary_expression => ( expression )\n", line);}
		;


postfix_expression 
		: primary_expression 
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => primary_expression\n", line);}
		| postfix_expression SQUARE_BRACKET_OPEN expression SQUARE_BRACKET_CLOSE
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => postfix_expression [ expression ]\n", line);}
		| postfix_expression ROUND_BRACKET_OPEN argument_expression_list_opt ROUND_BRACKET_CLOSE
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => postfix_expression ( argument_expression_list_opt )\n", line);}
		| postfix_expression DOT IDENTIFIER
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => postfix_expression DOT IDENTIFIER\n", line);}
		| postfix_expression IMPLIES IDENTIFIER
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => postfix_expression IMPLIES IDENTIFIER\n", line);}
		| postfix_expression UNARY_INCREMENT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => postfix_expression UNARY_INCREMENT\n", line);}
		| postfix_expression UNARY_DECREMENT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => postfix_expression UNARY_DECREMENT\n", line);}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE 
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => ( type_name ) { initializer_list }\n", line);}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE 
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : postfix_expression => ( type_name ) {initializer_list ,}\n", line);}
		;


argument_expression_list_opt 
	  	: argument_expression_list
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : argument_expression_list_opt => argument_expression_list\n", line);}
	  	| 
        {     printf("Line %d -> Rule 1 : EXPRESSIONS : argument_expression_list_opt => epsilon\n", line);}
	  	;


argument_expression_list 
		: assignment_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : argument_expression_list => assignment_expression\n", line);}
	  	| argument_expression_list COMMA assignment_expression
	    {     printf("Line %d -> Rule 1 : EXPRESSIONS : argument_expression_list => assignment_expression_list , assignment_expression\n", line);}
	  	;


unary_expression 
		: postfix_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_expression => postfix_expression\n", line);}
		| UNARY_INCREMENT unary_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_expression => UNARY_INCREMENT unary_expression\n", line);}
		| UNARY_DECREMENT unary_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_expression => UNARY_DECREMENT unary_expression\n", line);}
		| unary_operator cast_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_expression => unary_operator cast_expression\n", line);}
		| SIZEOF unary_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_expression => SIZEOF unary_expression\n", line);}
		| SIZEOF ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_expression => SIZEOF ( type_name )\n", line);}
		;


unary_operator
		: BITWISE_AND
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_operator => BITWISE_AND\n", line);}
		| MUL
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_operator => MUL\n", line);}
		| PLUS
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_operator => PLUS\n", line);}
		| MINUS
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_operator => MINUS\n", line);}
		| COMPLEMENT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_operator => COMPLEMENT\n", line);}
		| NOT
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : unary_operator => NOT\n", line);}
		;


cast_expression 
		: unary_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : cast_expression => unary_expression\n", line);}
		| ROUND_BRACKET_OPEN type_name ROUND_BRACKET_CLOSE cast_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : cast_expression => ( type_name ) cast_expression\n", line);}
		;


multiplicative_expression 
		: cast_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : multiplicative_expression => cast_expression\n", line);}
		| multiplicative_expression MUL cast_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : multiplicative_expression => multiplicative_expression MUL cast_expression\n", line);}
		| multiplicative_expression DIV cast_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : multiplicative_expression => multiplicative_expression DIV cast_expression\n", line);}
		| multiplicative_expression MOD cast_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : multiplicative_expression => multiplicative_expression MOD cast_expression\n", line);}
		;


additive_expression 
		: multiplicative_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : additive_expression => multiplicative_expression\n", line);}
		| additive_expression PLUS multiplicative_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : additive_expression => additive_expression PLUS multiplicative_expression\n", line);}
		| additive_expression MINUS multiplicative_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : additive_expression => additive_expression MINUS multiplicative_expression\n", line);}
		;


shift_expression 
		: additive_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : shift_expression => additive_expression\n", line);}
		| shift_expression BITWISE_LEFT additive_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : shift_expression => shift_expression BITWISE_LEFT additive_expression\n", line);}
		| shift_expression BITWISE_RIGHT additive_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : shift_expression => shift_expression BITWISE_RIGHT additive_expression\n", line);}
		;


relational_expression 
		: shift_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : relational_expression => shift_expression\n", line);}
		| relational_expression LESS_THAN shift_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : relational_expression => relational_expression LESS_THAN shift_expression\n", line);}
		| relational_expression GREATER_THAN shift_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : relational_expression => relational_expression GREATER_THAN shift_expression\n", line);}
		| relational_expression LESS_EQUAL shift_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : relational_expression => relational_expression LESS_EQUAL shift_expression\n", line);}
		| relational_expression GREATER_EQUAL shift_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : relational_expression => relational_expression GREATER_EQUAL shift_expression\n", line);}
		;


equality_expression 
		: relational_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : equality_expression => relational_expression\n", line);}
		| equality_expression EQUAL relational_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : equality_expression => equality_expression EQUAL relational_expression\n", line);}
		| equality_expression NOT_EQUAL relational_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : equality_expression => equality_expression NOT_EQUAL relational_expression\n", line);}
		;


AND_expression 
		: equality_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : AND_expression => equality_expression\n", line);}
		| AND_expression BITWISE_AND equality_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : AND_expression => AND_expression BITWISE_AND equality_expression\n", line);}
		;


exclusive_OR_expression 
		: AND_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : exclusive_OR_expression => AND_expression\n", line);}
		| exclusive_OR_expression XOR AND_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : exclusive_OR_expression => exclusive_OR_expression XOR AND_expression\n", line);}
		;


inclusive_OR_expression 
		: exclusive_OR_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : inclusive_OR_expression => exclusive_OR_expression\n", line);}
		| inclusive_OR_expression BITWISE_OR exclusive_OR_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : inclusive_OR_expression => inclusive_OR_expression BITWISE_OR exclusive_OR_expression\n", line);}
 		;


logical_AND_expression 
		: inclusive_OR_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : logical_AND_expression => inclusive_OR_expression\n", line);}
		| logical_AND_expression LOGICAL_AND inclusive_OR_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : logical_AND_expression => logical_AND_expression LOGICAL_AND inclusive_OR_expression\n", line);}
		;


logical_OR_expression 
		: logical_AND_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : logical_OR_expression => logical_AND_expression\n", line);}
		| logical_OR_expression LOGICAL_OR logical_AND_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : logical_OR_expression => logical_OR_expression LOGICAL_OR logical_AND_expression\n", line);}
		;


conditional_expression 
		: logical_OR_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : conditional_expression => logical_OR_expression\n", line);}
		| logical_OR_expression QUES_MARK expression COLON conditional_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : conditional_expression => logical_OR_expression QUES_MARK expression COLON conditional_expression\n", line);}
		;


assignment_expression 
		: conditional_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_expression => conditional_expression\n", line);}
		| unary_expression assignment_operator assignment_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_expression => unary_expression assignment_operator assignment_expression\n", line);}
		;


assignment_operator
		: ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => ASSIGN\n", line);}
		| MUL_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => MUL_ASSIGN\n", line);}
		| DIV_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => DIV_ASSIGN\n", line);}
		| MOD_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => MOD_ASSIGN\n", line);}
		| PLUS_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => PLUS_ASSIGN\n", line);}
		| MINUS_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => MINUS_ASSIGN\n", line);}
		| BITWISE_LEFT_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => BITWISE_LEFT_ASSIGN\n", line);}
		| BITWISE_RIGHT_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => BITWISE_RIGHT_ASSIGN\n", line);}
		| BITWISE_AND_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => BITWISE_AND_ASSIGN\n", line);}
		| XOR_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => XOR_ASSIGN\n", line);}
		| BITWISE_OR_ASSIGN
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : assignment_operator => BITWISE_OR_ASSIGN\n", line);}
		;


expression 
		: assignment_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : expression => assignment_expression\n", line);}
		| expression COMMA assignment_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : expression => expression COMMA assignment_expression\n", line);}
		;


constant_expression 
		: conditional_expression
		{     printf("Line %d -> Rule 1 : EXPRESSIONS : constant_expression => conditional_expression\n", line);}
		;


// -------------------------------- 2. DECLARATIONS ------------------------------


declaration 
		: declaration_specifiers init_declarator_list_opt SEMICOLON
		{     printf("Line %d -> Rule 2 : DECLARATIONS : declaration => declaration_specifiers init_declarator_list_opt SEMICOLON\n", line);}
		;


init_declarator_list_opt 
		: init_declarator_list
        {     printf("Line %d -> Rule 1 : DECLARATIONS : init_declarator_list_opt => init_declarator_list\n", line);}
		| 
        {     printf("Line %d -> Rule 1 : DECLARATIONS : init_declarator_list_opt => epsilon\n", line);}
		;


declaration_specifiers 
		: storage_class_specifier declaration_specifiers_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : declaration_specifiers => storage_class_specifier declaration_specifiers_opt\n", line);}
		| type_specifier declaration_specifiers_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : declaration_specifiers => type_specifier declaration_specifiers_opt\n", line);}
		| type_qualifier declaration_specifiers_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : declaration_specifiers => type_qualifier declaration_specifiers_opt\n", line);}
		| function_specifier declaration_specifiers_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : declaration_specifiers => function_specifier declaration_specifiers_opt\n", line);}
		;


declaration_specifiers_opt 
		: declaration_specifiers
		{     printf("Line %d -> Rule 1 : DECLARATIONS : declaration_specifiers_opt => declaration_specifiers\n", line);}
		| 
        {     printf("Line %d -> Rule 1 : DECLARATIONS : declaration_specifiers_opt => epsilon\n", line);}
		;


init_declarator_list 
		: init_declarator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : init_declarator_list => init_declarator\n", line);}
		| init_declarator_list COMMA init_declarator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : init_declarator_list => init_declarator_list COMMA init_declarator\n", line);}
		;


init_declarator 
		: declarator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : init_declarator => declarator\n", line);}
		| declarator ASSIGN initializer
		{     printf("Line %d -> Rule 2 : DECLARATIONS : init_declarator => declarator ASSIGN initializer\n", line);}
		;


storage_class_specifier 
		: EXTERN
		{     printf("Line %d -> Rule 2 : DECLARATIONS : storage_class_specifier => EXTERN\n", line);}
		| STATIC
		{     printf("Line %d -> Rule 2 : DECLARATIONS : storage_class_specifier => STATIC\n", line);}
        | AUTO
		{     printf("Line %d -> Rule 2 : DECLARATIONS : storage_class_specifier => AUTO\n", line);}
        | REGISTER
		{     printf("Line %d -> Rule 2 : DECLARATIONS : storage_class_specifier => REGISTER\n", line);}
		;


type_specifier 
		: VOID
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => VOID\n", line);}
		| CHAR
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => CHAR\n", line);}
		| SHORT
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => SHORT\n", line);}
		| INT
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => INT\n", line);}
		| LONG
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => LONG\n", line);}
		| FLOAT
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => FLOAT\n", line);}
		| DOUBLE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => DOUBLE\n", line);}
        | SIGNED
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => SIGNED\n", line);}
        | UNSIGNED
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => UNSIGNED\n", line);}
        | BOOL
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => BOOL\n", line);}
        | COMPLEX
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => COMPLEX\n", line);}
        | IMAGINARY
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => IMAGINARY\n", line);}
        | enum_specifier
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_specifier => enum_specifier\n", line);}
		;


specifier_qualifier_list 
		: type_specifier specifier_qualifier_list_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : specifier_qualifier_list => type_specifier specifier_qualifier_list_opt\n", line);}
		| type_qualifier specifier_qualifier_list_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : specifier_qualifier_list => type_qualifier specifier_qualifier_list_opt\n", line);}
		;

specifier_qualifier_list_opt 
		: specifier_qualifier_list
		{     printf("Line %d -> Rule 1 : DECLARATIONS : specifier_qualifier_list_opt => specifier_qualifier_list\n", line);}
		| 
        {     printf("Line %d -> Rule 1 : DECLARATIONS : specifier_qualifier_list_opt => epsilon\n", line);}
		;

enum_specifier
        : ENUM identifier_opt CURLY_BRACKET_OPEN enumerator_list CURLY_BRACKET_CLOSE
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enum_specifier => ENUM identifier_opt CURLY_BRACKET_OPEN enumerator_list CURLY_BRACKET_CLOSE\n", line);}
        | ENUM identifier_opt CURLY_BRACKET_OPEN enumerator_list COMMA CURLY_BRACKET_CLOSE
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enum_specifier => ENUM identifier_opt CURLY_BRACKET_OPEN enumerator_list COMMA CURLY_BRACKET_CLOSE\n", line);}
        | ENUM IDENTIFIER
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enum_specifier => ENUM IDENTIFIER\n", line);}
        ;

identifier_opt
        : IDENTIFIER
        {     printf("Line %d -> Rule 2 : DECLARATIONS : identifier_opt => IDENTIFIER\n", line);}
        | 
        {     printf("Line %d -> Rule 2 : DECLARATIONS : identifier_opt => epsilon\n", line);}
        ;

enumerator_list
        : enumerator
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enumerator_list => enumerator\n", line);}
        | enumerator_list COMMA enumerator
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enumerator_list => enumerator_list COMMA enumerator\n", line);}
        ;

enumerator
        : IDENTIFIER
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enumerator => IDENTIFIER\n", line);}
        | IDENTIFIER EQUAL constant_expression
        {     printf("Line %d -> Rule 2 : DECLARATIONS : enumerator => IDENTIFIER EQUAL constant_expression\n", line);}
        ;

type_qualifier 
		: CONST
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier => CONST\n", line);}
		| RESTRICT
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier => RESTRICT\n", line);}
		| VOLATILE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier => VOLATILE\n", line);}
		;


function_specifier 
		: INLINE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : function_specifier => INLINE\n", line);}
		;


declarator 
		: pointer_opt direct_declarator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : declarator => pointer_opt direct_declarator\n", line);}
		;


direct_declarator 
		: IDENTIFIER
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => IDENTIFIER\n", line);}
		| ROUND_BRACKET_OPEN declarator ROUND_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => ( declarator )\n", line);}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list_opt assignment_expression_opt SQUARE_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => \n", line);}
		| direct_declarator SQUARE_BRACKET_OPEN STATIC type_qualifier_list_opt assignment_expression SQUARE_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => direct_declarator [ STATIC type_qualifier_list_opt assignment_expression ]\n", line);}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list STATIC assignment_expression SQUARE_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => direct_declarator [ type_qualifier_list STATIC assignment_expression ]\n", line);}
		| direct_declarator SQUARE_BRACKET_OPEN type_qualifier_list_opt MUL SQUARE_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => direct_declarator [ type_qualifier_list_opt MUL ]\n", line);}
		| direct_declarator ROUND_BRACKET_OPEN parameter_type_list ROUND_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => direct_declarator ( parameter_type_list )\n", line);}
		| direct_declarator ROUND_BRACKET_OPEN identifier_list_opt ROUND_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : direct_declarator => direct_declarator ( identifier_list_opt )\n", line);}
		;


pointer 
		: MUL type_qualifier_list_opt
		{     printf("Line %d -> Rule 2 : DECLARATIONS : pointer => MUL type_qualifier_list_opt\n", line);}
		| MUL type_qualifier_list_opt pointer
		{     printf("Line %d -> Rule 2 : DECLARATIONS : pointer => MUL type_qualifier_list_opt pointer\n", line);}
		;


pointer_opt 
		: pointer
        {     printf("Line %d -> Rule 2 : DECLARATIONS : pointer_opt => pointer\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : DECLARATIONS : pointer_opt => epsilon\n", line);}
		;


assignment_expression_opt 
		: assignment_expression
		{     printf("Line %d -> Rule 2 : DECLARATIONS : pointer_opt => pointer\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : DECLARATIONS : pointer_opt => epsilon\n", line);}
		;


type_qualifier_list 
		: type_qualifier
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier_list => type_qualifier\n", line);}
		| type_qualifier_list type_qualifier
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier_list => type_qualifier_list type_qualifier\n", line);}
		;


type_qualifier_list_opt 
		: type_qualifier_list
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier_list_opt => type_qualifier_list\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : DECLARATIONS : type_qualifier_list_opt => epsilon\n", line);}
		;


parameter_type_list 
		: parameter_list
		{     printf("Line %d -> Rule 2 : DECLARATIONS : parameter_type_list => parameter_list\n", line);}
		| parameter_list COMMA DOTS
		{     printf("Line %d -> Rule 2 : DECLARATIONS : parameter_type_list => parameter_list COMMA DOTS\n", line);}
		;


parameter_list 
		: parameter_declaration
		{     printf("Line %d -> Rule 2 : DECLARATIONS : parameter_list => parameter_declaration\n", line);}
		| parameter_list COMMA parameter_declaration
		{     printf("Line %d -> Rule 2 : DECLARATIONS : parameter_list => parameter_list COMMA parameter_declaration\n", line);}
		;


parameter_declaration 
		: declaration_specifiers declarator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : parameter_declaration => declaration_specifiers declarator\n", line);}
		| declaration_specifiers
		{     printf("Line %d -> Rule 2 : DECLARATIONS : parameter_declaration => declaration_specifiers\n", line);}
		;


identifier_list 
		: IDENTIFIER
		{     printf("Line %d -> Rule 2 : DECLARATIONS : identifier_list => IDENTIFIER\n", line);}
		| identifier_list COMMA IDENTIFIER
		{     printf("Line %d -> Rule 2 : DECLARATIONS : identifier_list => identifier_list COMMA IDENTIFIER\n", line);}
		;


identifier_list_opt 
		: identifier_list
		{     printf("Line %d -> Rule 2 : DECLARATIONS : identifier_list_opt => identifier_list\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : DECLARATIONS : identifier_list_opt => epsilon\n", line);}
		;


type_name 
		: specifier_qualifier_list
		{     printf("Line %d -> Rule 2 : DECLARATIONS : type_name => specifier_qualifier_list\n", line);}
		;


initializer 
		: assignment_expression
		{     printf("Line %d -> Rule 2 : DECLARATIONS : initializer => assignment_expression\n", line);}
		| CURLY_BRACKET_OPEN initializer_list CURLY_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : initializer => ( initializer_list )\n", line);}
		| CURLY_BRACKET_OPEN initializer_list COMMA CURLY_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : initializer => ( initializer_list COMMA )\n", line);}
		;


initializer_list 
		: designation_opt initializer
		{     printf("Line %d -> Rule 2 : DECLARATIONS : initializer_list => designation_opt initializer\n", line);}
		| initializer_list COMMA designation_opt initializer
		{     printf("Line %d -> Rule 2 : DECLARATIONS : initializer_list => initializer_list COMMA designation_opt initializer\n", line);}
		;


designation 
		: designator_list ASSIGN
		{     printf("Line %d -> Rule 2 : DECLARATIONS : designation => designator_list ASSIGN\n", line);}
		;


designation_opt 
		: designation
		{     printf("Line %d -> Rule 2 : DECLARATIONS : designation_opt => designation\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : DECLARATIONS : designation_opt => epsilon\n", line);}
		;


designator_list 
		: designator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : designator_list => designator\n", line);}
		| designator_list designator
		{     printf("Line %d -> Rule 2 : DECLARATIONS : designator_list => designator_list designator\n", line);}
		;


designator 
		: SQUARE_BRACKET_OPEN constant_expression SQUARE_BRACKET_CLOSE
		{     printf("Line %d -> Rule 2 : DECLARATIONS : designator => [ constant_expression ]\n", line);}
		| DOT IDENTIFIER
		{     printf("Line %d -> Rule 2 : DECLARATIONS : designator => DOT IDENTIFIER\n", line);}
		;


// -------------------------------- 3. STATEMENTS ------------------------------


statement 
		: labeled_statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : statement => labeled_statement\n", line);}
		| compound_statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : statement => compound_statement\n", line);}
		| expression_statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : statement => expression_statement\n", line);}
		| selection_statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : statement => selection_statement\n", line);}
		| iteration_statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : statement => iteration_statement\n", line);}
		| jump_statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : statement => jump_statement\n", line);}
		;


labeled_statement 
		: IDENTIFIER COLON statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : labeled_statement => IDENTIFIER COLON statement\n", line);}
		| CASE constant_expression COLON statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : labeled_statement => CASE constant_expression COLON statement\n", line);}
		| DEFAULT COLON statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : labeled_statement => DEFAULT COLON statement\n", line);}
		;


compound_statement 
		: CURLY_BRACKET_OPEN block_item_list_opt CURLY_BRACKET_CLOSE
		{     printf("Line %d -> Rule 3 : STATEMENTS : compound_statement => { block_item_list_opt }\n", line);}
		;


block_item_list 
		: block_item
		{     printf("Line %d -> Rule 3 : STATEMENTS : block_item_list => block_item\n", line);}
		| block_item_list block_item
		{     printf("Line %d -> Rule 3 : STATEMENTS : block_item_list => block_item_list block_item\n", line);}
		;


block_item 
		: declaration
		{     printf("Line %d -> Rule 3 : STATEMENTS : block_item => declaration\n", line);}
		| statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : block_item => statement\n", line);}
		;


block_item_list_opt 
		: block_item_list
		{     printf("Line %d -> Rule 2 : STATEMENTS : block_item_list_opt => block_item_list\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : STATEMENTS : block_item_list_opt => epsilon\n", line);}
		;


expression_statement 
		: expression_opt SEMICOLON
		{     printf("Line %d -> Rule 3 : STATEMENTS : expression_statement => expression_opt SEMICOLON\n", line);}
		;


expression_opt 
		: expression
		{     printf("Line %d -> Rule 2 : STATEMENTS : expression_opt => expression\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : STATEMENTS : expression_opt => epsilon\n", line);}
		;


selection_statement 
		: IF ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement %prec LOWER_THAN_ELSE
		{     printf("Line %d -> Rule 3 : STATEMENTS : selection_statement => IF ( expression ) statement\n", line);}
		| IF ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement ELSE statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : selection_statement => IF ( expression ) statement ELSE statement\n", line);}
		| SWITCH ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : selection_statement => SWITCH ( expression ) statement\n", line);}
		;


iteration_statement 
		: WHILE ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : iteration_statement => WHILE ( expression ) statement\n", line);}
		| DO statement WHILE ROUND_BRACKET_OPEN expression ROUND_BRACKET_CLOSE SEMICOLON
		{     printf("Line %d -> Rule 3 : STATEMENTS : iteration_statement => DO statement WHILE ( expression ) SEMICOLON\n", line);}
		| FOR ROUND_BRACKET_OPEN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt ROUND_BRACKET_CLOSE statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : iteration_statement => FOR ( expression_opt SEMICOLON expression_opt SEMICOLON expression_opt ) statement\n", line);}
		| FOR ROUND_BRACKET_OPEN declaration expression_opt SEMICOLON expression_opt ROUND_BRACKET_CLOSE statement
		{     printf("Line %d -> Rule 3 : STATEMENTS : iteration_statement => FOR ( declaration expression_opt SEMICOLON expression_opt ) statement\n", line);}
		;


jump_statement 
		: GOTO IDENTIFIER SEMICOLON
		{     printf("Line %d -> Rule 3 : STATEMENTS : jump_statement => GOTO IDENTIFIER SEMICOLON\n", line);}
		| CONTINUE SEMICOLON
		{     printf("Line %d -> Rule 3 : STATEMENTS : jump_statement => CONTINUE SEMICOLON\n", line);}
		| BREAK SEMICOLON
		{     printf("Line %d -> Rule 3 : STATEMENTS : jump_statement => BREAK SEMICOLON\n", line);}
		| RETURN expression_opt SEMICOLON
		{     printf("Line %d -> Rule 3 : STATEMENTS : jump_statement => RETURN expression_opt SEMICOLON\n", line);}
		;


// -------------------------------- 4. EXTERNAL DEFINITIONS  --------------------


translation_unit 
		: external_declaration
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : translation_unit => external_declaration\n", line);}
		| translation_unit external_declaration
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : translation_unit => translation_unit external_declaration\n", line);}
		;


external_declaration
		: function_definition
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : external_declaration => function_definition\n", line);}
		| declaration
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : external_declaration => declaration\n", line);}
		;


function_definition
		: declaration_specifiers declarator declaration_list_opt compound_statement
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : function_definition => declaration_specifiers declarator declaration_list_opt compound_statement\n", line);}
		;


declaration_list
		: declaration
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : declaration_list => declaration\n", line);}
        | declaration_list declaration
		{     printf("Line %d -> Rule 4 : EXTERNAL DEFINITIONS : declaration_list => declaration_list declaration\n", line);}
		;


declaration_list_opt
		: declaration_list
		{     printf("Line %d -> Rule 2 : EXTERNAL DEFINITIONS : declaration_list_opt => declaration_list\n", line);}
		| 
        {     printf("Line %d -> Rule 2 : EXTERNAL DEFINITIONS : declaration_list_opt => epsilon\n", line);}
		;


%%

// Called on error in case invalid input is obtained that cannot
// parsed by the parser generated by Bison
void yyerror(char *s) {  
	printf("Error in Line %d is: %s\n", line, s);
}

